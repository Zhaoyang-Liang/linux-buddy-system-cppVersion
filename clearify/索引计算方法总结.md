# Buddy系统索引计算方法总结

## 1. 父子节点关系

### 父节点 → 子节点
```c
// 左子节点
left_child = parent * 2 + 1;

// 右子节点  
right_child = parent * 2 + 2;
```

### 子节点 → 父节点
```c
// 任意子节点到父节点
parent = (child + 1) / 2 - 1;
```

## 2. 兄弟节点关系

### 计算兄弟节点
```c
int buddy = index - 1 + (index & 1) * 2;
```

**推导过程**：
- 奇数节点（左子）：兄弟是 `index + 1`
- 偶数节点（右子）：兄弟是 `index - 1`
- 统一公式：`index - 1 + (index & 1) * 2`

**验证例子**：
```c
// 节点3（奇数）
buddy = 3 - 1 + (3 & 1) * 2 = 2 + 2 = 4 ✓

// 节点4（偶数）
buddy = 4 - 1 + (4 & 1) * 2 = 3 + 0 = 3 ✓
```

## 3. 内存偏移地址计算

### 节点索引 → 内存偏移地址
```c
static inline int _index_offset(int index, int level, int max_level)
{
    return ((index + 1) - (1 << level)) << (max_level - level);
}
```

**参数说明**：
- `index`：节点索引
- `level`：节点所在层数（从0开始）
- `max_level`：树的最大层数

**计算例子**：
```c
// 节点7 (index=7, level=3, max_level=3)
offset = ((7 + 1) - (1 << 3)) << (3 - 3)
       = (8 - 8) << 0 = 0

// 节点8 (index=8, level=3, max_level=3)
offset = ((8 + 1) - (1 << 3)) << (3 - 3)
       = (9 - 8) << 0 = 1
```

## 4. 树结构相关计算

### 计算总节点数
```c
// 对于level层的完全二叉树
total_nodes = (1 << level) * 2 - 1;
// 或者
total_nodes = (1 << (level + 1)) - 1;
```

### 计算每层节点数
```c
// 第i层的节点数
nodes_at_level_i = 1 << i;
```

### 计算每层第一个节点索引
```c
// 第i层第一个节点的索引
first_node_at_level_i = (1 << i) - 1;
```

## 5. 内存分配相关计算

### 判断是否为2的幂
```c
static inline int is_pow_of_2(uint32_t x)
{
    return !(x & (x - 1));
}
```

**原理**：
- 2的幂的二进制只有一个1
- `x & (x - 1)` 会将最低位的1变成0
- 如果结果是0，说明原来只有一个1

### 计算下一个2的幂
```c
static inline uint32_t next_pow_of_2(uint32_t x)
{
    if (is_pow_of_2(x))
        return x;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    return x + 1;
}
```

**原理**：
- 通过位移和或运算，将最高位1右边的所有位都变成1
- 然后加1得到下一个2的幂

## 6. 搜索相关计算

### 在buddy_free中的地址计算
```c
// 判断偏移地址在哪一半
if (offset < left + length)
{
    // 在左半部分，搜索左子节点
    index = index * 2 + 1;
}
else
{
    // 在右半部分，搜索右子节点
    left += length;
    index = index * 2 + 2;
}
```

**参数说明**：
- `offset`：要查找的偏移地址
- `left`：当前节点的左边界
- `length`：当前节点管理的长度

## 7. 具体例子验证

### 例子：level=3的完全二叉树
```
        0 (level 0)
       / \
      1   2 (level 1)
     / \ / \
    3  4 5  6 (level 2)
   / \/ \/ \/ \
   7 8 9 10 11 12 13 14 (level 3)
```

**验证计算**：
- 总节点数：`(1 << 3) * 2 - 1 = 8 * 2 - 1 = 15`
- 第1层节点数：`1 << 1 = 2`
- 第1层第一个节点：`(1 << 1) - 1 = 1`
- 节点3的父节点：`(3 + 1) / 2 - 1 = 1`
- 节点1的左子节点：`1 * 2 + 1 = 3`
- 节点1的右子节点：`1 * 2 + 2 = 4`
- 节点3的兄弟节点：`3 - 1 + (3 & 1) * 2 = 2 + 2 = 4`

## 8. 内存布局计算

### 节点到地址的映射
```c
// 节点7的内存偏移地址
// index=7, level=3, max_level=3
offset = ((7 + 1) - (1 << 3)) << (3 - 3)
       = (8 - 8) << 0 = 0

// 节点8的内存偏移地址
// index=8, level=3, max_level=3
offset = ((8 + 1) - (1 << 3)) << (3 - 3)
       = (9 - 8) << 0 = 1
```

## 9. 状态管理计算

### 父节点状态更新
```c
// 回到父节点
index = (index + 1) / 2 - 1;

// 检查父节点状态
if (self->tree[index] == NODE_FULL)
{
    self->tree[index] = NODE_SPLIT;
}
```

### 兄弟节点检查
```c
// 计算兄弟节点
int buddy = index - 1 + (index & 1) * 2;

// 检查是否可以合并
if (buddy >= 0 && self->tree[buddy] == NODE_UNUSED)
{
    // 可以合并
}
```

## 10. 常用计算模式

### 位运算技巧
```c
// 判断奇偶性
if (index & 1) {
    // 奇数（左子节点）
} else {
    // 偶数（右子节点）
}

// 计算2的幂
power_of_2 = 1 << n;  // 2^n

// 判断是否为2的幂
is_power_of_2 = !(x & (x - 1));
```

### 树遍历模式
```c
// 深度优先搜索
while (index >= 0) {
    if (condition) {
        // 处理当前节点
        return result;
    } else {
        // 继续搜索子节点
        index = index * 2 + direction;
    }
}
```

## 总结

这些计算方法构成了Buddy系统的核心：

1. **树结构导航**：父子节点、兄弟节点关系
2. **地址转换**：节点索引与内存地址的转换
3. **内存管理**：2的幂次计算、内存分配
4. **搜索算法**：根据地址定位节点
5. **状态管理**：节点状态的更新和维护

这些计算确保了Buddy系统能够高效地管理内存分配和释放，是理解整个系统的基础。
